Во многих операционных системах (Linux, MacOS) существует утилита `du`. Она умеет считать место в указанных файлах и директориях. Например, так:

``` bash
tmp$ du -sh *
  0B    com.docker.vmnetd.socket
 10M    credo
4.0K    debug.mjs
  0B    filesystemui.socket
4.0K    index.php
 37M    vendor
 88K    composer-lock.json
 22M    taxdome
```

Перед тем, как делать упражнение, обязательно попробуйте поиграйте с этой утилитой в терминале, посмотрите её опции через `man du`. Экспериментировать нужно в локально установленной операционной системе.

## src/du.php

Реализуйте функцию `du()`, которая принимает на вход директорию, а возвращает список узлов вложенных, (директорий и файлов) в указанную директорию на один уровень, и место, которое они занимают. Размер файла задается в метаданных. Размер директории складывается из сумм всех размеров файлов, находящихся внутри во всех подпапках. Сами папки размера не имеют.

## Пример

``` php
<?php

use function Php\Immutable\Fs\Trees\trees\mkdir;
use function Php\Immutable\Fs\Trees\trees\mkfile;
use function App\du\du;

$tree = mkdir('/', [
    mkdir('etc', [
        mkdir('apache'),
        mkdir('nginx', [
            mkfile('nginx.conf', ['size' => 800]),
        ]),
        mkdir('consul', [
            mkfile('config.json', ['size' => 1200]),
            mkfile('data', ['size' => 8200]),
            mkfile('raft', ['size' => 80]),
        ]),
    ]),
    mkfile('hosts', ['size' => 3500]),
    mkfile('resolve', ['size' => 1000]),
]);

du($tree);
// [
//     ['etc', 10280],
//     ['hosts', 3500],
//     ['resolve', 1000],
// ]
```

## Примечания

* Обратите внимание на структуру результирующего массива. Каждый элемент — массив с двумя значениями: именем директории и размером файлов внутри.
* Результат отсортирован по размеру в обратном порядке. То есть сверху самые тяжёлые, внизу самые лёгкие.

## Подсказки

* [usort](https://www.php.net/manual/ru/function.usort.php)

